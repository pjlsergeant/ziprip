// ziprip.js - version 0.0.3 - docs: http://zipripjs.com/
// Copyright Peter Sergeant pete@clueball.com - MIT License
// This file is automatically generated, don't edit directly.

// Synopsis:
//     var addresses = ziprip.extract( dom, urlString )
//
// Full documentation at http://zipripjs.com/

(function () {

var libraries = {};

var zrRequire = function (name) {
    return libraries[name]();
}


// Imported from: src/address.js
libraries['./address'] = function () {
    var exports = {};
// File contents begin

//
// Address Objects
//
// Consider: "Prime Minister's Residence, 10 Downing Street, SW1A 2AA, UK"
//
// Attributes:
//   title    - A title for the address: "Prime Minister's Residence" in the
//              example above. This may be the same as the first item in 'atoms'
//   atoms    - An array of strings, representing the street address. Could be
//              empty. ["10 Downing Street"] in the example above.
//   postcode - The postcode or zipcode for the address. Will always be set.
//              "SW1A 2AA" in the example above.
//   country  - The country the address is in. Will always be set. Current
//              possible values are 'US' and 'UK' - "UK" in the example above.
//   lat/lon  - Coordinates for the address. Some extractors will also be able
//              to determine these, so they're included. Should be either
//              undefined or signed integer. Undefined in the example above.
//
// Methods:
//   isGeocoded       - Boolean - are lat and lon set?
//   flatten          - Returns atoms, postcode, and country as one flat list.
//                      ["10 Downing Street", "SW1A 2AA", "UK"]
//   formatForGeocode - Returns a string suitable for passing to a geocoder.
//                      Country is included only if it's not 'US', and other
//                      fields are comma-delimited, with title ommitted.
//                      "10 Downing Street, SW1A 2AA, UK"
//

// Define an address object to wrap outgoing addresses in
exports.address = function () {

    // Members
    this['title']    = '';
    this['atoms']    = [];
    this['postcode'] = '';
    this['country']  = '';
    this['lat']      = undefined;
    this['lon']      = undefined;
    this['via']      = '';

    // Return true or false depending on if we also found coordinates from the
    // address
    this.isGeocoded = function () {
        if (
            (typeof this['lat']) != 'undefined' &&
            (typeof this['lon']) != 'undefined'
        ) {
            return true;
        } else {
            return false;
        }
    }

    // Returns all the constitutent parts of the address as a list of strings.
    // This explicitly does NOT include the title. If you don't want the
    // country, lop off the last part.
    this.flatten = function () {
        var parts = [];

        // Add the atoms
        parts = parts.concat( this['atoms'] );

        // And the final bits
        if (this['postcode']) parts.push( this['postcode'] );
        parts.push( this['country']  );

        return parts;
    }

    // Return in a format suitable for most geocoders. US-Centric Capitalist
    // Geocoders, that is...
    this.formatForGeocode = function () {
        var parts = this.flatten();
        var country = parts[parts.length-1];

        // Every Geocoder I've seen just assumes the US, and some get quite
        // confused if you mention it... Plus, is it US? Or United States? You'd
        // think Geocoders could handle that, yet...
        if ( country == 'US' ) {
            parts.pop();
        }

        return parts.join(', ');
    }

    // One day I need to work out why isDeeply doesn't like shared functions,
    // but until then, this is a little easier...
    this._fieldsOnly = function () {
        var testObject = {};
        var attr = ['title','atoms','postcode','country','via','lat','lon'];
        for (var i = 0; i < attr.length; i++ ) {
            if ((typeof this[attr[i]]) == 'function') continue;
            testObject[attr[i]] = this[attr[i]];
        }
        return testObject;
    }
}

exports.addressFromFields = function (fields) {
    var addressObject = new exports.address;
    for (var key in fields) {
        addressObject[key] = fields[key];
    }
    return addressObject;
}

// File contents end
    return exports;
}


// Imported from: src/addressFromString.js
libraries['./addressFromString'] = function () {
    var exports = {};
// File contents begin

var postcodes = [
    { "country": "UK", "one_only": true,  "regex_string":'\\b([a-z]\\d\\s\\d[a-z][a-z]|[a-z]\\d[a-z]\\s\\d[a-z][a-z]|[a-z]\\d\\d\\s\\d[a-z][a-z]|[a-z]\\d\\d[a-z]\\s\\d[a-z][a-z]|[a-z][a-z]\\d\\s\\d[a-z][a-z]|[a-z][a-z]\\d[a-z]\\s\\d[a-z][a-z]|[a-z][a-z]\\d\\d\\s\\d[a-z][a-z])\\b' },
    { "country": "US", "one_only": false, "regex_string":'\\b((Chicago,?|Houston,?|Philadelphia,?|Phoenix,?|Alabama,?|Alaska,?|Arizona,?|Arkansas,?|California,?|Colorado,?|Connecticut,?|Delaware,?|Florida,?|Georgia,?|Hawaii,?|Idaho,?|Illinois,?|Indiana,?|Iowa,?|Kansas,?|Kentucky,?|Louisiana,?|Maine,?|Maryland,?|Massachusetts,?|Michigan,?|Minnesota,?|Mississippi,?|Missouri,?|Montana,?|North Carolina,?|North Dakota,?|Nebraska,?|Nevada,?|New Hampshire,?|New Jersey,?|New Mexico,?|New York,?|Ohio,?|Oklahoma,?|Oregon,?|Pennsylvania,?|Rhode Island,?|South Carolina,?|South Dakota,?|Tennessee,?|Texas,?|Utah,?|Vermont,?|Virginia,?|Washington,?|West Virginia,?|Wisconsin,?|Wyoming,?|American Samoa,?|D\\.C\\.,?|Guam,?|Puerto Rico,?|AL|AK|AZ|AR|CA|CO|CT|DE|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|NC|ND|NE|NV|NH|NJ|NM|NY|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY|AS|DC|GU|MP|PR|VI)\\s+\\d{5}(-\\d{4})?)\\b' }
];

// Add the block RE to each postcode block, and make real RegExps
for (var i = 0; i < postcodes.length; i++) {
    postcodes[i]['regex'] = new RegExp( postcodes[i]['regex_string'], 'i' );
    // Multi-line capture before hand
    postcodes[i]['regex_block'] = new RegExp( '([\\s\\S]+)(' + postcodes[i]['regex_string'] + ')', 'i' );
}

exports.addressFromString = function ( toolkit, text ) {

    // Build up addresses here
    var addresses  = [];

    // Postcodes we've already seen
    var codes_seen = {};

    // Attempt to split incoming text in to paragraphs
    var blocks = text.split(/\n\s*\n/);

    // In our first attempt, we pull out strings that end with postcodes, and
    // all that came before it in the block. So start with the Cartesian Product
    // of blocks and postcode types...
    for (var i = 0; i < blocks.length; i++) {
        var block = blocks[i];
        var address = [];

        for (var ii = 0; ii < postcodes.length; ii++) {
            var country = postcodes[ii];

            // Do we match some stuff and then a postcode? Add some padding to
            // our block so we'll always have a leading block if we wanted one
            var padded = '  ' + block;
            var match = padded.match( country['regex_block'] );
            if ( match ) {
                var prefix   = match[1];
                var postcode = match[2];

                // For some countries, postcodes are specific enough that we
                // don't want to match twice
                if ( country['one_only'] ) {
                    if ( codes_seen[postcode] ) {
                        break;
                    } else {
                        codes_seen[postcode] = 1;
                    }
                }

                // It had something before the postcode
                if ( prefix.match(/\w/) ) {
                    address = [ prefix, postcode, country['country'] ];
                // Just the postcode (and maybe some space)
                } else {
                    address = [ postcode, country['country'] ];
                }
                break;
            }

            // Stop checking if we found an address
            if ( address.length > 0 ) { break; }
        }

        // Did we find something?
        if ( address.length > 0 ) {
            addresses.push( address );
        }
    }

    // Partial addresses with just a postcode, try a little harder to find an
    // address for it...
    var deletedOnTheFly = false;
    for (var i = 0; i < addresses.length; i++) {
        var address = addresses[i];

        // Check it's a postcode-only address
        if ( address.length != 2 ) continue;

        var postcode = address[0];

        // Traverse through the blocks again, this time paying close attention
        // to our index
        var foundAtoms = [];

        for ( var it = 0; it < blocks.length; it++ ) {
            // If a line has our postcode on it (and if we got here (no chaff)
            // then it'll be the only thing on the line, then we trace backward
            if ( blocks[it].match( postcode ) ) {
                var cursor = 0;
                for ( cursor = (it - 1); cursor >= 0; cursor-- ) {
                    var block = blocks[cursor];
                    //if ( block.length > 40 ) { break }
                    if ( block.match(/\n/) ) { break }
                    if ( block.match(/http:/) ) { break }
                    if ( block.match(/\baddress/i) ) { break }
                    foundAtoms.unshift( block );
                }
                break;
            }
        }

        if ( foundAtoms.length ) {
            addresses[i] = [ foundAtoms.join(', '), address[0], address[1] ];
        } else {
            deletedOnTheFly = true;
            addresses[i] = undefined;
        }
    }

    // Remove any we set to undefined
    if ( deletedOnTheFly ) {
        var newAddresses = [];
        for (var i=0; i < addresses.length; i++) {
            if ( addresses[i] ) {
                newAddresses.push( addresses[i] );
            }
        }
        addresses = newAddresses;
    }

    // Now we have some rough-hewn addresses, attempt to clean out any extra
    // data we captured
    for (var i=0; i < addresses.length; i++) {

        var prefix   = addresses[i][0];
        var postcode = addresses[i][1];
        var country  = addresses[i][2];

        // General address prefixing stuff to remove
        prefix = prefix.replace(/^.*(Registered Offices?( is| are)?|Tel|Telephone|Website|Fax|Address)\s*:\s*/mi, '');

        // Characters used for splitting atoms -> ,s
        prefix = prefix.replace(/[\n|]/g, ',');
        prefix = prefix.replace(/\u2022/g, ',');
        prefix = prefix.replace(/%u2022/g, ',');

        // Split it up in to parts, either by comma...
        prefix = prefix.replace(/,+/g, ',');
        prefix = prefix.replace(/,\s*$/g, '');
        var atoms = prefix.split(/,/);

        // Or on double-spaces if that didn't work
        if ( atoms.length == 1 ) {
            if ( atoms[0].match(/\s\s/) ) {
                atoms = atoms[0].split(/\s\s/);
            }
        }

        // Clean and sort atoms, including trying to get street numbers on their
        // own line on to the right line...
        var postAtoms = [];     // Accumulate in to this
        var orphan_number = ''; // Orphan number
        for (var ii = 0; ii < atoms.length; ii++) {
            var atom = atoms[ii];

            atom = atom.replace(/^\s*registered offices?( is| are)?/, '');
            atom = atom.replace(/^\s*\*\s*/, '' );
            atom = atom.replace(/^\s+/, '' );
            atom = atom.replace(/\s+$/, '' );
            atom = atom.replace(/\s+/g, ' ');
            atom = atom.replace(/,$/, '' );

            var number_only = atom.match(/^\d[ \d\-ab]*$/i);
            if ( number_only ) {
                orphan_number = atom;
            } else if ( atom.length && atom.length < 38 ) {
                if ( orphan_number ) {
                    atom = orphan_number + ' ' + atom;
                    orphan_number = undefined;
                }
                postAtoms.push( atom )
            }
        }

        // Clean up postcodes with too many delimiting spaces
        postcode = postcode.replace(/\s+/g, ' ');

        var title = postAtoms[0];
        if ( title == undefined || ! title.length ) {
            title = postcode;
        }

        addresses[i] = toolkit.addressFromFields({
            'atoms': postAtoms,
            'title': title,
            'country': country,
            'postcode': postcode
        });

    }

    return addresses;
}

// File contents end
    return exports;
}


// Imported from: src/cleanAddress_en.js
libraries['./cleanAddress_en'] = function () {
    var exports = {};
// File contents begin

// These are Street Name atoms. The clean algorithm says that an address
// starts on the last line that contains one of these atoms and a number, OR the
// line before the last line that contains one of them if not.

var streetNameRE = new RegExp(' (Road|Rd|Square|Street|St\.?|Parkway|Pkwy\.?|Ave\.?|Avenue|Broadway|Boulevard|Blvd.?|Lane|Terrace|Place|Gardens|Yard|Court|Way|Drive|Dr\.?|lazy)( (north|west|south|east))?$', 'i');

exports.cleanAddress = function (atomsOriginal) {

    // Reverse the address atoms
    var atoms = atomsOriginal.reverse();

    // This is where we'll store atoms we want to keep
    var newAtoms = [];

    for (var i = 0; i < atoms.length; i++) {

        // Add this atom to the list
        newAtoms.unshift( atoms[i] );

        // If it's a street name
        if ( atoms[i].match( streetNameRE ) ) {
            // And it has a number, then break
            if ( atoms[i].match(/\d/) ) {
                break;
            // Otherwise, try and add the next item too, and then break
            } else {
                if ( (i+1) != atoms.length ) {
                    newAtoms.unshift( atoms[i+1] );
                    break;
                }
            }
        }
    }

    // TODO: This is where we should be taking a copy, but aren't...
    return newAtoms;
}

// File contents end
    return exports;
}


// Imported from: src/domToText.js
libraries['./domToText'] = function () {
    var exports = {};
// File contents begin

// Given a DOM object, returns a simple text representation
// Turns a DOM in to plain text. Requires a toolkit with at
//
exports.domToText = function ( dom, toolkit ) {

    // Nodes that we ignore the contents of
    var skipNodes = {
        'head':   1,
        'script': 1,
        'style':  1
    };

    // Nodes that map to text values
    var nodeMappings = {
        'h1_start'  : "\n\n",
        'h2_start'  : "\n\n",
        'h3_start'  : "\n\n",
        'p_start'   : "\n",
        'p_end'     : "\n",
        'span_start': "",
        'span_end'  : ", ",
        'div_start' : "\n",
        'div_end'   : "\n\n",
        'li_end'    : "\n",
        'br_end'    : "\n",
        'td_end'    : "\n\n"
    };

    var capture = '';

    function nodeGrab ( node, depth, path ) {

        var localName = '';
        if ( node.nodeName ) { localName = node.nodeName.toLowerCase(); }

        // Traverse in to iFrames too
        if ( localName == 'iframe' ) {
            var newDoc;
            try { newDoc = node.contentDocument.documentElement }
            catch (e) {}

            if (newDoc) {
                capture += "\n\n\n\n";
                nodeGrab( newDoc, depth + 1, path + ' > ' + localName  );
            }

        // 3: Text element
        } else if ( node.nodeType == 3 ) {
            var rText = toolkit.nodeToText(node);
            capture += rText;

        // 1: Tag element
        } else if ( node.nodeType == 1 ) {
            var insertion;

            // Skip some nodes...
            if ( skipNodes[ localName ] ) {
                return;

            // Lookup nodes whose start means newlines, and add them
            } else if ( insertion = nodeMappings[ localName + '_start' ] ) {
                capture += insertion;
            }

            // Recurse in to any child nodes
            for (var i = 0; i < node.childNodes.length; i++) {
                nodeGrab( node.childNodes[i], depth + 1, path + ' > ' + localName  );
            }

            // Add in any ending newlines
            if ( insertion = nodeMappings[ localName + '_end' ] ) {
                capture += insertion;
            }
        }
    }

    nodeGrab( dom.getElementsByTagName('html')[0], 0, '' );
    return capture;
}

// File contents end
    return exports;
}


// Imported from: src/extractUsing.js
libraries['./extractUsing'] = function () {
    var exports = {};
// File contents begin

// This is the core function. It accepts a DOM, a toolbox that has a
// well-specified interface, and a list of extractors to try and use
exports.extractUsing = function ( dom, url, toolkit, stash, extractors ) {

    // Reload Sizzle with this DOM
    toolkit.loadSizzle( dom );

    // Where we'll store the addresses we find
    var addresses = [];

    // Loop over each extractor
    for (var i = 0; i < extractors.length; i++) {

        // Attempt to find addresses using that
        var found = extractors[i]( dom, url, toolkit, stash );

        // If we did, we can break the loop
        if ( found && found.length > 0 ) {
            addresses = found;
            break;
        }
    }

    // Clean the addresses we found using the cleanAddress() function in the
    // toolkit
    for (var i = 0; i < addresses.length; i++) {
        if ( addresses[i]['via'] == 'Generic' ) {
            addresses[i]['atoms'] = toolkit.cleanAddress( addresses[i]['atoms'] );
        }
    }

    // It's possible we found some geocoding hints in the Google extractor, but
    // an address elsewhere. If we found a coordinate hint, and just one address
    // then we match those up now.
    if ( addresses.length == 1 ) {
        if ( stash['hint'] ) {
            if (! addresses[0]['lat'] ) {
                addresses[0]['lat'] = stash['hint'][0];
                addresses[0]['lon'] = stash['hint'][1];
            }
        }
    }

    return addresses;
};
// File contents end
    return exports;
}


// Imported from: src/extractorFromText.js
libraries['./extractorFromText'] = function () {
    var exports = {};
// File contents begin

// Generic extractor
exports.extractor = function ( dom, url, toolkit, stash ) {
    var documentAsText = toolkit.domToText( dom, toolkit );
    var addresses = toolkit.addressFromString( toolkit, documentAsText );
    for (var i = 0; i < addresses.length; i++) {
        addresses[i]['via'] = 'Generic';
    }
    return addresses;
}

// File contents end
    return exports;
}


// Imported from: src/extractorGoogle.js
libraries['./extractorGoogle'] = function () {
    var exports = {};
// File contents begin

// All sortsa Google magic
exports.extractor = function ( dom, url, toolkit, stash ) {

    // RHS Blocks - these are inline address blocks normally in Google results
    // pages.
    var rhsBlock = toolkit.sz('#rhs_block .rhsvw a[href*="daddr"]', dom)[0];
    if ( rhsBlock ) {
        var found = extractDURLS([ rhsBlock ])[0];
        if ( found ) {
            var title = toolkit.sz('#rhs_block .rhsvw b', dom)[0];
            if ( title && toolkit.nodeToText(title) ) {
                found['title'] = toolkit.nodeToText(title);
            }
            found['via'] = 'Google RHS';
            return [found];
        }
    }


    // PP Marker, which is a big chunk of json with useful stuff in
    var ppMarkers = toolkit.sz('#pp-marker-json', dom)[0];
    if ( ppMarkers ) {
        var markerContent = toolkit.nodeToText(ppMarkers);
        var addresses = extractPPMarker( markerContent );
        if ( addresses.length ) { return addresses }
    }


    // Google IDs
    var gurls = toolkit.sz('div[g\\:url]', dom);
    var found = extractGURLS(gurls);
    if ( found.length ) { return found }


    // Driving instructions
    var durls = toolkit.sz('a[href*="daddr"]', dom);
    var dfound = extractDURLS( durls );
    if ( dfound.length ) { return dfound }

    // Address hinting? We pull out Google's coords for use on other addresses
    // found by other extractors
    var hints = toolkit.sz('a[href*="mapclient=jsapi"]', dom);
    if ( hints.length == 1 ) {
        var url = hints[0].getAttribute('href');
        url = toolkit.uri(url);
        if (url.host().match('maps.google') ) {
            var ll = url.decode( url.getQueryParamValue('ll') ).split(',');
            if ( ll[0] && ll[1] ) {
                stash.hint = ll;
            }
        }
    }

    // Google Driving URLs
    function extractDURLS ( durls ) {
        var addresses = [];
        for (var i = 0; i < durls.length; i++ ) {
            var durl = durls[i];
            var url = toolkit.uri( durl.getAttribute('href') );

            // Gotta be Google Maps URLs, for starters
            if (! url.host().match('maps.google') ) { continue }

            // Pull out the 'daddr' attribute
            var daddr = url.decode( url.getQueryParamValue('daddr') );

            // Parse that
            var parsedAddress = toolkit.addressFromString( toolkit, daddr )[0];
            if (! parsedAddress ) { continue; }

            // Try and get the coordinates for it
            var geocode = url.decode( url.getQueryParamValue('geocode') );
            if ( geocode ) {
                var atoms = geocode.split(/,/);
                if ( atoms.length != 3 ) { continue }
                parsedAddress['lat'] = atoms[1];
                parsedAddress['lon'] = atoms[2];
                parsedAddress['via'] = 'Google Driving';
            } else {
                continue;
            }

            // Make a ditch at the title if there was just one...
            if ( durls.length == 1 ) {
                var lclbox = toolkit.sz('*[id="lclbox"]', dom)[0];
                if (lclbox) {
                    var title = toolkit.sz('*[class="wrt"]',lclbox)[0];
                    if ( title ) {
                        parsedAddress['title'] = toolkit.nodeToText(title);
                    }
                }
            }

            addresses.push( parsedAddress );
        }

        return addresses;
    }


    function extractGURLS ( gurls ) {
        var addresses = [];
        var seen = {};

        for (var i = 0; i < gurls.length; i++) {
            var url = gurls[i].getAttribute('g:url');

            // Only process each one once
            if ( seen[url] ) { continue; }
            seen[url] = 1;

            // Remove the preceeding ID crap
            url = url.replace(/^ID:\/\//, '');

            // Now we can treat it like a real URL
            url = toolkit.uri( url );
            if (! url.host().match('maps.google') ) { continue }

            var address = url.decode( url.getQueryParamValue('q') );

            var parts = address.split(/loc\:/);
            var title  = parts[0];
            var street = parts[1];

            // Remove phone numbers from titles
            title = title.replace(/[\-\d\(\)\ \+]+$/g, '');
            title = title.replace(/\s*$/g, '');
            title = title.replace(/^\s*/g, '');
            title = title.replace(/\s+/g, ' ');

            var parsedAddress = toolkit.addressFromString( toolkit, street )[0];

            if (! parsedAddress ) { continue; }

            var ll = url.getQueryParamValue('sll').split(/,/);
            parsedAddress['lat'] = ll[0];
            parsedAddress['lon'] = ll[1];
            parsedAddress['title'] = title;
            parsedAddress['via'] = 'Google g:url';
            addresses.push( parsedAddress );
        }

        return addresses;
    }


    function extractPPMarker (text) {

        // Our JSON parser unhappy with Google-style bare JSON keys
        text = text.replace(/(\w+):/g, "\"$1\":");

        // It works, or we don't care...
        try {
            var jsonD  = toolkit.json.parse( text );
            var title  = jsonD['infoWindow']['title'];
            var asText = jsonD['infoWindow']['addressLines'].join(',');
            var lat    = jsonD['latlng']['lat'] + 0;
            var lon    = jsonD['latlng']['lng'] + 0;
        } catch ( e ) { return [] }

        if (! asText.length ) { return [] }

        var parsedAddress = toolkit.addressFromString( toolkit, asText )[0];

        if (! parsedAddress ) { return [] }

        if ( title.length ) { parsedAddress['title'] = title }

        if ( lat && lon ) {
            parsedAddress['lat'] = lat;
            parsedAddress['lon'] = lon;
        }

        parsedAddress['via'] = 'Google pp-marker';

        return [parsedAddress];
    }


}


// File contents end
    return exports;
}


// Imported from: src/extractorHVCard.js
libraries['./extractorHVCard'] = function () {
    var exports = {};
// File contents begin


exports.extractor = function ( dom, url, toolkit, stash ) {

    var addresses = [];
    var seen = {};
    var cardElements = toolkit.sz('*[class~="hcard"],*[class~="vcard"]');

    for (var i=0; i < cardElements.length; i++) {
        var card = cardElements[i];

        // Attempt to get the title first of all
        var orgName;
        var org = toolkit.sz('*[class~="org"]', card)[0];
        if (org) orgName = toolkit.nodeToText(org);

        // Now string together other bits of the address
        var addr = toolkit.sz('*[class~="adr"]', card)[0];
        if (! addr) continue;

        var asText = '';

        var parts = [
            'street-address', 'extended-adddress', 'locality', 'region',
            'postal-code','country-name'
        ];

        for (var ii=0; ii < parts.length; ii++) {
            var part = parts[ii];
            var atom = toolkit.sz('*[class~="' + part + '"]', addr)[0];

            if ( atom ) {
                var val = toolkit.nodeToText(atom);

                // Fix up postcodes if they're weird...
                if (part == 'postal-code') {
                    val = val.replace(/^\s*(\d\d\d\d\d)(\d\d\d\d)\s*$/, "$1-$2")
                }

                // Append these parts. We append with a newline, except for
                // region, as we don't want to split that from a postcode
                if (part == 'region') {
                    asText += val + ' ';
                } else {
                    asText += val + "\n";
                }
            }
        }

        if (! seen[asText]) {
            seen[asText] = 1;
            var parsedAddress = toolkit.addressFromString( toolkit, asText )[0];

            if ( parsedAddress ) {
                parsedAddress['atoms'] = toolkit.cleanAddress( parsedAddress['atoms'] );
                parsedAddress['via'] = 'hvCard';
                if (orgName) {
                    parsedAddress['title'] = orgName;
                    if ( parsedAddress['atoms'][0] == orgName ) {
                        parsedAddress['atoms'].shift();
                    }
                }
                addresses.push( parsedAddress );
            }
        }
    }

    return addresses;
}

// File contents end
    return exports;
}


// Imported from: src/json2.js
libraries['./json2'] = function () {
    var exports = {};
// File contents begin

/*
http://www.JSON.org/json2.js - 2011-10-19 - Public Domain. - NO WARRANTY
EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK. - See http://www.JSON.org/js.html

Minor modifications by Peter Sergeant, licensed as per ziprip.
*/

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables. Build the JSON
// parser in zrJSON which we'll then expor
zrJSON = {};

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof zrJSON.stringify !== 'function') {
        zrJSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('zrJSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof zrJSON.parse !== 'function') {
        zrJSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('zrJSON.parse');
        };
    }
}());

exports.json = zrJSON;

// File contents end
    return exports;
}


// Imported from: src/jsuri.js
libraries['./jsuri'] = function () {
    var exports = {};
// File contents begin
/*!
 * jsUri v1.1.1
 * https://github.com/derek-watson/jsUri
 *
 * Copyright 2011, Derek Watson
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Includes parseUri regular expressions
 * http://blog.stevenlevithan.com/archives/parseuri
 * Copyright 2007, Steven Levithan
 * Released under the MIT license.
 *
 * Date: Mon Nov 14 20:06:34 2011 -0800
 */

/*
 * Modified for compatibility with ziprip by Peter Sergeant pete@clueball.com */

var Query = function (queryString) {

    // query string parsing, parameter manipulation and stringification

    'use strict';

    var // parseQuery(q) parses the uri query string and returns a multi-dimensional array of the components
        parseQuery = function (q) {
            var arr = [], i, ps, p, keyval;

            if (typeof (q) === 'undefined' || q === null || q === '') {
                return arr;
            }

            if (q.indexOf('?') === 0) {
                q = q.substring(1);
            }

            ps = q.toString().split(/[&;]/);

            for (i = 0; i < ps.length; i++) {
                p = ps[i];
                keyval = p.split('=');
                arr.push([keyval[0], keyval[1]]);
            }

            return arr;
        },

        params = parseQuery(queryString),

        // toString() returns a string representation of the internal state of the object
        toString = function () {
            var s = '', i, param;
            for (i = 0; i < params.length; i++) {
                param = params[i];
                if (s.length > 0) {
                    s += '&';
                }
                s += param.join('=');
            }
            return s.length > 0 ? '?' + s : s;
        },

        decode = function (s) {
            s = decodeURIComponent(s);
            s = s.replace(/\+/g, ' ');
            return s;
        },

        // getParamValues(key) returns the first query param value found for the key 'key'
        getParamValue = function (key) {
            var param, i;
            for (i = 0; i < params.length; i++) {
                param = params[i];
                if (decode(key) === decode(param[0])) {
                    return param[1];
                }
            }
        },

        // getParamValues(key) returns an array of query param values for the key 'key'
        getParamValues = function (key) {
            var arr = [], i, param;
            for (i = 0; i < params.length; i++) {
                param = params[i];
                if (decode(key) === decode(param[0])) {
                    arr.push(param[1]);
                }
            }
            return arr;
        },

        // deleteParam(key) removes all instances of parameters named (key)
        // deleteParam(key, val) removes all instances where the value matches (val)
        deleteParam = function (key, val) {

            var arr = [], i, param, keyMatchesFilter, valMatchesFilter;

            for (i = 0; i < params.length; i++) {

                param = params[i];
                keyMatchesFilter = decode(param[0]) === decode(key);
                valMatchesFilter = decode(param[1]) === decode(val);

                if ((arguments.length === 1 && !keyMatchesFilter) || (arguments.length === 2 && !keyMatchesFilter && !valMatchesFilter)) {
                    arr.push(param);
                }
            }

            params = arr;

            return this;
        },

        // addParam(key, val) Adds an element to the end of the list of query parameters
        // addParam(key, val, index) adds the param at the specified position (index)
        addParam = function (key, val, index) {

            if (arguments.length === 3 && index !== -1) {
                index = Math.min(index, params.length);
                params.splice(index, 0, [key, val]);
            } else if (arguments.length > 0) {
                params.push([key, val]);
            }
            return this;
        },

        // replaceParam(key, newVal) deletes all instances of params named (key) and replaces them with the new single value
        // replaceParam(key, newVal, oldVal) deletes only instances of params named (key) with the value (val) and replaces them with the new single value
        // this function attempts to preserve query param ordering
        replaceParam = function (key, newVal, oldVal) {

            var index = -1, i, param;

            if (arguments.length === 3) {
                for (i = 0; i < params.length; i++) {
                    param = params[i];
                    if (decode(param[0]) === decode(key) && decodeURIComponent(param[1]) === decode(oldVal)) {
                        index = i;
                        break;
                    }
                }
                deleteParam(key, oldVal).addParam(key, newVal, index);
            } else {
                for (i = 0; i < params.length; i++) {
                    param = params[i];
                    if (decode(param[0]) === decode(key)) {
                        index = i;
                        break;
                    }
                }
                deleteParam(key);
                addParam(key, newVal, index);
            }
            return this;
        };

    // public api
    return {
        getParamValue: getParamValue,
        getParamValues: getParamValues,
        deleteParam: deleteParam,
        addParam: addParam,
        replaceParam: replaceParam,
        decode: decode, /* Pete added this */
        toString: toString
    };
};

exports.uri = function (uriString) {

    // uri string parsing, attribute manipulation and stringification

    'use strict';

    /*global Query: true */
    /*jslint regexp: false, plusplus: false */

    var strictMode = false,

        // parseUri(str) parses the supplied uri and returns an object containing its components
        parseUri = function (str) {

            /*jslint unparam: true */
            var parsers = {
                    strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                    loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
                },
                keys = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
                q = {
                    name: "queryKey",
                    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
                },
                m = parsers[strictMode ? "strict" : "loose"].exec(str),
                uri = {},
                i = 14;

            while (i--) {
                uri[keys[i]] = m[i] || "";
            }

            uri[q.name] = {};
            uri[keys[12]].replace(q.parser, function ($0, $1, $2) {
                if ($1) {
                    uri[q.name][$1] = $2;
                }
            });

            return uri;
        },

        uriParts = parseUri(uriString || ''),

        queryObj = new Query(uriParts['query']),


        /*
            Basic get/set functions for all properties
        */

        protocol = function (val) {
            if (typeof val !== 'undefined') {
                uriParts['protocol'] = val;
            }
            return uriParts['protocol'];
        },

        hasAuthorityPrefixUserPref = null,

        // hasAuthorityPrefix: if there is no protocol, the leading // can be enabled or disabled
        hasAuthorityPrefix = function (val) {

            if (typeof val !== 'undefined') {
                hasAuthorityPrefixUserPref = val;
            }

            if (hasAuthorityPrefixUserPref === null) {
                return (uriParts['source'].indexOf('//') !== -1);
            } else {
                return hasAuthorityPrefixUserPref;
            }
        },

        userInfo = function (val) {
            if (typeof val !== 'undefined') {
                uriParts['userInfo'] = val;
            }
            return uriParts['userInfo'];
        },

        host = function (val) {
            if (typeof val !== 'undefined') {
                uriParts['host'] = val;
            }
            return uriParts['host'];
        },

        port = function (val) {
            if (typeof val !== 'undefined') {
                uriParts['port'] = val;
            }
            return uriParts['port'];
        },

        path = function (val) {
            if (typeof val !== 'undefined') {
                uriParts['path'] = val;
            }
            return uriParts['path'];
        },

        query = function (val) {
            if (typeof val !== 'undefined') {
                queryObj = new Query(val);
            }
            return queryObj;
        },

        anchor = function (val) {
            if (typeof val !== 'undefined') {
                uriParts['anchor'] = val;
            }
            return uriParts['anchor'];
        },


        /*
            Fluent setters for Uri uri properties
        */

        setProtocol = function (val) {
            protocol(val);
            return this;
        },

        setHasAuthorityPrefix = function (val) {
            hasAuthorityPrefix(val);
            return this;
        },

        setUserInfo = function (val) {
            userInfo(val);
            return this;
        },

        setHost = function (val) {
            host(val);
            return this;
        },

        setPort = function (val) {
            port(val);
            return this;
        },

        setPath = function (val) {
            path(val);
            return this;
        },

        setQuery = function (val) {
            query(val);
            return this;
        },

        setAnchor = function (val) {
            anchor(val);
            return this;
        },

        /*
            Query method wrappers
        */
        getQueryParamValue = function (key) {
            return query().getParamValue(key);
        },

        getQueryParamValues = function (key) {
            return query().getParamValues(key);
        },

        decode = function (key) {
            return query().decode(key);
        },

        deleteQueryParam = function (key, val) {
            if (arguments.length === 2) {
                query().deleteParam(key, val);
            } else {
                query().deleteParam(key);
            }

            return this;
        },

        addQueryParam = function (key, val, index) {
            if (arguments.length === 3) {
                query().addParam(key, val, index);
            } else {
                query().addParam(key, val);
            }
            return this;
        },

        replaceQueryParam = function (key, newVal, oldVal) {
            if (arguments.length === 3) {
                query().replaceParam(key, newVal, oldVal);
            } else {
                query().replaceParam(key, newVal);
            }

            return this;
        },

        /*
            Serialization
        */

        // toString() stringifies the current state of the uri
        toString = function () {

            var s = '',
                is = function (s) {
                    return (s !== null && s !== '');
                };

            if (is(protocol())) {
                s += protocol();
                if (protocol().indexOf(':') !== protocol().length - 1) {
                    s += ':';
                }
                s += '//';
            } else {
                if (hasAuthorityPrefix() && is(host())) {
                    s += '//';
                }
            }

            if (is(userInfo()) && is(host())) {
                s += userInfo();
                if (userInfo().indexOf('@') !== userInfo().length - 1) {
                    s += '@';
                }
            }

            if (is(host())) {
                s += host();
                if (is(port())) {
                    s += ':' + port();
                }
            }

            if (is(path())) {
                s += path();
            } else {
                if (is(host()) && (is(query().toString()) || is(anchor()))) {
                    s += '/';
                }
            }
            if (is(query().toString())) {
                if (query().toString().indexOf('?') !== 0) {
                    s += '?';
                }
                s += query().toString();
            }

            if (is(anchor())) {
                if (anchor().indexOf('#') !== 0) {
                    s += '#';
                }
                s += anchor();
            }

            return s;
        },

        /*
            Cloning
        */

        // clone() returns a new, identical Uri instance
        clone = function () {
            return new Uri(toString());
        };

    // public api
    return {

        protocol: protocol,
        hasAuthorityPrefix: hasAuthorityPrefix,
        userInfo: userInfo,
        host: host,
        port: port,
        path: path,
        query: query,
        anchor: anchor,

        setProtocol: setProtocol,
        setHasAuthorityPrefix: setHasAuthorityPrefix,
        setUserInfo: setUserInfo,
        setHost: setHost,
        setPort: setPort,
        setPath: setPath,
        setQuery: setQuery,
        setAnchor: setAnchor,

        getQueryParamValue: getQueryParamValue,
        getQueryParamValues: getQueryParamValues,
        deleteQueryParam: deleteQueryParam,
        addQueryParam: addQueryParam,
        replaceQueryParam: replaceQueryParam,

        decode: decode,

        toString: toString,
        clone: clone
    };
};


// File contents end
    return exports;
}


// Imported from: src/nodeToText.js
libraries['./nodeToText'] = function () {
    var exports = {};
// File contents begin

exports.nodeToText = function ( elem ) {
    var text = '';
    try {
        text = elem.textContent.replace(/\n/g, ' ');
        return text;
    } catch (e) {1;}
    try {
        if ( elem.nodeType == 3 ) {
            text = elem.nodeValue;
        } else if ( elem.noteType == 1 ) {
            text = elem.innerText.replace(/\n/g, ' ');
            return text;
        }
    } catch (e) {1;}

    return text;
}
// File contents end
    return exports;
}


// Imported from: src/sizzle.js
libraries['./sizzle'] = function () {
    var exports = {};
// File contents begin
/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2012, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 *
 */

/*
	Based on jquery/sizzle a0523a509429
	with modifications (that might be worth diffing)
*/

var currentSizzle;

// Each new DOM requires us to reload Sizzle, basically.
exports.sz = function (selector) {
	return currentSizzle(selector);
}

exports.loadSizzle = function ( dom, context ) {
	currentSizzle = instantiateSizzle( dom, context );
}

var instantiateSizzle = function( dom, undefined ) {

var cachedruns,
	dirruns,
	sortOrder,
	siblingCheck,
	assertGetIdNotName,

	docElem = dom.documentElement,

	strundefined = "undefined",
	hasDuplicate = false,
	baseHasDuplicate = true,
	done = 0,
	slice = [].slice,
	push = [].push,

	expando = ( "sizcache" + Math.random() ).replace( ".", "" ),

	// Regex

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	operators = "([*^$|!~]?=)",
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",
	pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|((?:[^,]|\\\\,|(?:,(?=[^\\[]*\\]))|(?:,(?=[^\\(]*\\))))*))\\)|)",
	pos = ":(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\)|)(?=[^-]|$)",
	combinators = whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*",
	groups = "(?=[^\\x20\\t\\r\\n\\f])(?:\\\\.|" + attributes + "|" + pseudos.replace( 2, 7 ) + "|[^\\\\(),])+",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcombinators = new RegExp( "^" + combinators ),

	// All simple (non-comma) selectors, excluding insignifant trailing whitespace
	rgroups = new RegExp( groups + "?(?=" + whitespace + "*,|$)", "g" ),

	// A selector, or everything after leading whitespace
	// Optionally followed in either case by a ")" for terminating sub-selectors
	rselector = new RegExp( "^(?:(?!,)(?:(?:^|,)" + whitespace + "*" + groups + ")*?|" + whitespace + "*(.*?))(\\)|$)" ),

	// All combinators and selector components (attribute test, tag, pseudo, etc.), the latter appearing together when consecutive
	rtokens = new RegExp( groups.slice( 19, -6 ) + "\\x20\\t\\r\\n\\f>+~])+|" + combinators, "g" ),

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

	rsibling = /[\x20\t\r\n\f]*[+~]/,
	rendsWithNot = /:not\($/,

	rheader = /h\d/i,
	rinputs = /input|select|textarea|button/i,

	rbackslash = /\\(?!\\)/g,

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "[-", "[-\\*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|nth|last|first)-child(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"POS": new RegExp( pos, "ig" ),
		// For use in libraries implementing .is()
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|" + pos, "i" )
	},

	classCache = {},
	cachedClasses = [],
	compilerCache = {},
	cachedSelectors = [],

	// Mark a function for use in filtering
	markFunction = function( fn ) {
		fn.sizzleFilter = true;
		return fn;
	},

	// Returns a function to use in pseudos for input types
	createInputFunction = function( type ) {
		return function( elem ) {
			// Check the input's nodeName and type
			return elem.nodeName.toLowerCase() === "input" && elem.type === type;
		};
	},

	// Returns a function to use in pseudos for buttons
	createButtonFunction = function( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	},

	// Used for testing something on an element
	assert = function( fn ) {
		var pass = false,
			div = dom.createElement("div");
		try {
			pass = fn( div );
		} catch (e) {}
		// release memory in IE
		div = null;
		return pass;
	},

	// Check if attributes should be retrieved by attribute nodes
	assertAttributes = assert(function( div ) {
		div.innerHTML = "<select></select>";
		var type = typeof div.lastChild.getAttribute("multiple");
		// IE8 returns a string for some attributes even when not present
		return type !== "boolean" && type !== "string";
	}),

	// Check if getElementById returns elements by name
	// Check if getElementsByName privileges form controls or returns elements by ID
	assertUsableName = assert(function( div ) {
		// Inject content
		div.id = expando + 0;
		div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
		docElem.insertBefore( div, docElem.firstChild );

		// Test
		var pass = dom.getElementsByName &&
			// buggy browsers will return fewer than the correct 2
			dom.getElementsByName( expando ).length ===
			// buggy browsers will return more than the correct 0
			2 + dom.getElementsByName( expando + 0 ).length;
		assertGetIdNotName = !dom.getElementById( expando );

		// Cleanup
		docElem.removeChild( div );

		return pass;
	}),

	// Check if the browser returns only elements
	// when doing getElementsByTagName("*")
	assertTagNameNoComments = assert(function( div ) {
		div.appendChild( dom.createComment("") );
		return div.getElementsByTagName("*").length === 0;
	}),

	// Check if getAttribute returns normalized href attributes
	assertHrefNotNormalized = assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
			div.firstChild.getAttribute("href") === "#";
	}),

	// Check if getElementsByClassName can be trusted
	assertUsableClassName = assert(function( div ) {
		// Opera can't find a second classname (in 9.6)
		div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
		if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
			return false;
		}

		// Safari caches class attributes, doesn't catch changes (in 3.2)
		div.lastChild.className = "e";
		return div.getElementsByClassName("e").length !== 1;
	});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || dom;
	var match, elem, xml, m,
		nodeType = context.nodeType;

	if ( nodeType !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	xml = isXML( context );

	if ( !xml && !seed ) {
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && assertUsableClassName && context.getElementsByClassName ) {
				push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
				return results;
			}
		}
	}
	// All others
	return select( selector, context, results, seed, xml );
};

var Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	match: matchExpr,

	order: [ "ID", "TAG" ],

	attrHandle: {},

	createPseudo: markFunction,

	find: {
		"ID": assertGetIdNotName ?
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined && !xml ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [m] : [];
				}
			} :
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined && !xml ) {
					var m = context.getElementById( id );

					return m ?
						m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
							[m] :
							undefined :
						[];
				}
			},

		"TAG": assertTagNameNoComments ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== strundefined ) {
					return context.getElementsByTagName( tag );
				}
			} :
			function( tag, context ) {
				var results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					var elem,
						tmp = [],
						i = 0;

					for ( ; (elem = results[i]); i++ ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			}
	},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( rbackslash, "" );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( rbackslash, "" );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr.CHILD
				1 type (only|nth|...)
				2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				3 xn-component of xn+y argument ([+-]?\d*n|)
				4 sign of xn-component
				5 x of xn-component
				6 sign of y-component
				7 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1] === "nth" ) {
				// nth-child requires argument
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[3] = +( match[3] ? match[4] + (match[5] || 1) : 2 * ( match[2] === "even" || match[2] === "odd" ) );
				match[4] = +( ( match[6] + match[7] ) || match[2] === "odd" );

			// other types prohibit arguments
			} else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var argument,
				unquoted = match[4];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Relinquish our claim on characters in `unquoted` from a closing parenthesis on
			if ( unquoted && (argument = rselector.exec( unquoted )) && argument.pop() ) {

				match[0] = match[0].slice( 0, argument[0].length - unquoted.length - 1 );
				unquoted = argument[0].slice( 0, -1 );
			}

			// Quoted or unquoted, we have the full argument
			// Return only captures needed by the pseudo filter method (type and argument)
			match.splice( 2, 3, unquoted || match[3] );
			return match;
		}
	},

	filter: {
		"ID": assertGetIdNotName ?
			function( id ) {
				id = id.replace( rbackslash, "" );
				return function( elem ) {
					return elem.getAttribute("id") === id;
				};
			} :
			function( id ) {
				id = id.replace( rbackslash, "" );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
					return node && node.value === id;
				};
			},

		"TAG": function( nodeName ) {
			if ( nodeName === "*" ) {
				return function() { return true; };
			}
			nodeName = nodeName.replace( rbackslash, "" ).toLowerCase();

			return function( elem ) {
				return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
			};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className ];
			if ( !pattern ) {
				pattern = classCache[ className ] = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" );
				cachedClasses.push( className );
				// Avoid too large of a cache
				if ( cachedClasses.length > Expr.cacheLength ) {
					delete classCache[ cachedClasses.shift() ];
				}
			}
			return function( elem ) {
				return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
			};
		},

		"ATTR": function( name, operator, check ) {
			if ( !operator ) {
				return function( elem ) {
					return Sizzle.attr( elem, name ) != null;
				};
			}

			return function( elem ) {
				var result = Sizzle.attr( elem, name ),
					value = result + "";

				if ( result == null ) {
					return operator === "!=";
				}

				switch ( operator ) {
					case "=":
						return value === check;
					case "!=":
						return value !== check;
					case "^=":
						return check && value.indexOf( check ) === 0;
					case "*=":
						return check && value.indexOf( check ) > -1;
					case "$=":
						return check && value.substr( value.length - check.length ) === check;
					case "~=":
						return ( " " + value + " " ).indexOf( check ) > -1;
					case "|=":
						return value === check || value.substr( 0, check.length + 1 ) === check + "-";
				}
			};
		},

		"CHILD": function( type, argument, first, last ) {

			if ( type === "nth" ) {
				var doneName = done++;

				return function( elem ) {
					var parent, diff,
						count = 0,
						node = elem;

					if ( first === 1 && last === 0 ) {
						return true;
					}

					parent = elem.parentNode;

					if ( parent && (parent[ expando ] !== doneName || !elem.sizset) ) {
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.sizset = ++count;
								if ( node === elem ) {
									break;
								}
							}
						}

						parent[ expando ] = doneName;
					}

					diff = elem.sizset - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
				};
			}

			return function( elem ) {
				var node = elem;

				switch ( type ) {
					case "only":
					case "first":
						while ( (node = node.previousSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						if ( type === "first" ) {
							return true;
						}

						node = elem;

						/* falls through */
					case "last":
						while ( (node = node.nextSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						return true;
				}
			};
		},

		"PSEUDO": function( pseudo, argument, context, xml ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			var fn = Expr.pseudos[ pseudo ] || Expr.pseudos[ pseudo.toLowerCase() ];

			if ( !fn ) {
				Sizzle.error( "unsupported pseudo: " + pseudo );
			}

			// The user may set fn.sizzleFilter to indicate
			// that arguments are needed to create the filter function
			// just as Sizzle does
			if ( !fn.sizzleFilter ) {
				return fn;
			}

			return fn( argument, context, xml );
		}
	},

	pseudos: {
		"not": markFunction(function( selector, context, xml ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var matcher = compile( selector.replace( rtrim, "$1" ), context, xml );
			return function( elem ) {
				return !matcher( elem );
			};
		}),

		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
			//   not comment, processing instructions, or others
			// Thanks to Diego Perini for the nodeName shortcut
			//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
			var nodeType;
			elem = elem.firstChild;
			while ( elem ) {
				if ( elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4 ) {
					return false;
				}
				elem = elem.nextSibling;
			}
			return true;
		},

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"text": function( elem ) {
			var type, attr;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" &&
				(type = elem.type) === "text" &&
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type );
		},

		// Input types
		"radio": createInputFunction("radio"),
		"checkbox": createInputFunction("checkbox"),
		"file": createInputFunction("file"),
		"password": createInputFunction("password"),
		"image": createInputFunction("image"),

		"submit": createButtonFunction("submit"),
		"reset": createButtonFunction("reset"),

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"focus": function( elem ) {
			var doc = elem.ownerDocument;
			return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href);
		},

		"active": function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},

	setFilters: {
		"first": function( elements, argument, not ) {
			return not ? elements.slice( 1 ) : [ elements[0] ];
		},

		"last": function( elements, argument, not ) {
			var elem = elements.pop();
			return not ? elements : [ elem ];
		},

		"even": function( elements, argument, not ) {
			var results = [],
				i = not ? 1 : 0,
				len = elements.length;
			for ( ; i < len; i = i + 2 ) {
				results.push( elements[i] );
			}
			return results;
		},

		"odd": function( elements, argument, not ) {
			var results = [],
				i = not ? 0 : 1,
				len = elements.length;
			for ( ; i < len; i = i + 2 ) {
				results.push( elements[i] );
			}
			return results;
		},

		"lt": function( elements, argument, not ) {
			return not ? elements.slice( +argument ) : elements.slice( 0, +argument );
		},

		"gt": function( elements, argument, not ) {
			return not ? elements.slice( 0, +argument + 1 ) : elements.slice( +argument + 1 );
		},

		"eq": function( elements, argument, not ) {
			var elem = elements.splice( +argument, 1 );
			return not ? elements : elem;
		}
	}
};

// Deprecated
Expr.setFilters["nth"] = Expr.setFilters["eq"];

// Back-compat
Expr.filters = Expr.pseudos;

// IE6/7 return a modified href
if ( !assertHrefNotNormalized ) {
	Expr.attrHandle = {
		"href": function( elem ) {
			return elem.getAttribute( "href", 2 );
		},
		"type": function( elem ) {
			return elem.getAttribute("type");
		}
	};
}

// Add getElementsByName if usable
if ( assertUsableName ) {
	Expr.order.push("NAME");
	Expr.find["NAME"] = function( name, context ) {
		if ( typeof context.getElementsByName !== strundefined ) {
			return context.getElementsByName( name );
		}
	};
}

// Add getElementsByClassName if usable
if ( assertUsableClassName ) {
	Expr.order.splice( 1, 0, "CLASS" );
	Expr.find["CLASS"] = function( className, context, xml ) {
		if ( typeof context.getElementsByClassName !== strundefined && !xml ) {
			return context.getElementsByClassName( className );
		}
	};
}

// If slice is not available, provide a backup
try {
	slice.call( docElem.childNodes, 0 )[0].nodeType;
} catch ( e ) {
	slice = function( i ) {
		var elem, results = [];
		for ( ; (elem = this[i]); i++ ) {
			results.push( elem );
		}
		return results;
	};
}

var isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

// Element contains another
var contains = Sizzle.contains = docElem.compareDocumentPosition ?
	function( a, b ) {
		return !!( a.compareDocumentPosition( b ) & 16 );
	} :
	docElem.contains ?
	function( a, b ) {
		var adown = a.nodeType === 9 ? a.documentElement : a,
			bup = b.parentNode;
		return a === bup || !!( bup && bup.nodeType === 1 && adown.contains && adown.contains(bup) );
	} :
	function( a, b ) {
		while ( (b = b.parentNode) ) {
			if ( b === a ) {
				return true;
			}
		}
		return false;
	};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (see #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	} else {

		// If no nodeType, this is expected to be an array
		for ( ; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	}
	return ret;
};

Sizzle.attr = function( elem, name ) {
	var attr,
		xml = isXML( elem );

	if ( !xml ) {
		name = name.toLowerCase();
	}
	if ( Expr.attrHandle[ name ] ) {
		return Expr.attrHandle[ name ]( elem );
	}
	if ( assertAttributes || xml ) {
		return elem.getAttribute( name );
	}
	attr = elem.getAttributeNode( name );
	return attr ?
		typeof elem[ name ] === "boolean" ?
			elem[ name ] ? name : null :
			attr.specified ? attr.value : null :
		null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

// Check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	return (baseHasDuplicate = 0);
});


if ( docElem.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		return ( !a.compareDocumentPosition || !b.compareDocumentPosition ?
			a.compareDocumentPosition :
			a.compareDocumentPosition(b) & 4
		) ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Document sorting and removing duplicates
Sizzle.uniqueSort = function( results ) {
	var elem,
		i = 1;

	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( ; (elem = results[i]); i++ ) {
				if ( elem === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

function multipleContexts( selector, contexts, results, seed ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results, seed );
	}
}

function handlePOSGroup( selector, posfilter, argument, contexts, seed, not ) {
	var results,
		fn = Expr.setFilters[ posfilter.toLowerCase() ];

	if ( !fn ) {
		Sizzle.error( posfilter );
	}

	if ( selector || !(results = seed) ) {
		multipleContexts( selector || "*", contexts, (results = []), seed );
	}

	return results.length > 0 ? fn( results, argument, not ) : [];
}

function handlePOS( selector, context, results, seed, groups ) {
	var match, not, anchor, ret, elements, currentContexts, part, lastIndex,
		i = 0,
		len = groups.length,
		rpos = matchExpr["POS"],
		// This is generated here in case matchExpr["POS"] is extended
		rposgroups = new RegExp( "^" + rpos.source + "(?!" + whitespace + ")", "i" ),
		// This is for making sure non-participating
		// matching groups are represented cross-browser (IE6-8)
		setUndefined = function() {
			var i = 1,
				len = arguments.length - 2;
			for ( ; i < len; i++ ) {
				if ( arguments[i] === undefined ) {
					match[i] = undefined;
				}
			}
		};

	for ( ; i < len; i++ ) {
		// Reset regex index to 0
		rpos.exec("");
		selector = groups[i];
		ret = [];
		anchor = 0;
		elements = seed;
		while ( (match = rpos.exec( selector )) ) {
			lastIndex = rpos.lastIndex = match.index + match[0].length;
			if ( lastIndex > anchor ) {
				part = selector.slice( anchor, match.index );
				anchor = lastIndex;
				currentContexts = [ context ];

				if ( rcombinators.test(part) ) {
					if ( elements ) {
						currentContexts = elements;
					}
					elements = seed;
				}

				if ( (not = rendsWithNot.test( part )) ) {
					part = part.slice( 0, -5 ).replace( rcombinators, "$&*" );
				}

				if ( match.length > 1 ) {
					match[0].replace( rposgroups, setUndefined );
				}
				elements = handlePOSGroup( part, match[1], match[2], currentContexts, elements, not );
			}
		}

		if ( elements ) {
			ret = ret.concat( elements );

			if ( (part = selector.slice( anchor )) && part !== ")" ) {
				multipleContexts( part, ret, results, seed );
			} else {
				push.apply( results, ret );
			}
		} else {
			Sizzle( selector, context, results, seed );
		}
	}

	// Do not sort if this is a single filter
	return len === 1 ? results : Sizzle.uniqueSort( results );
}

function tokenize( selector, context, xml ) {
	var tokens, soFar, type,
		groups = [],
		i = 0,

		// Catch obvious selector issues: terminal ")"; nonempty fallback match
		// rselector never fails to match *something*
		match = rselector.exec( selector ),
		matched = !match.pop() && !match.pop(),
		selectorGroups = matched && selector.match( rgroups ) || [""],

		preFilters = Expr.preFilter,
		filters = Expr.filter,
		checkContext = !xml && context !== dom;

	for ( ; (soFar = selectorGroups[i]) != null && matched; i++ ) {
		groups.push( tokens = [] );

		// Need to make sure we're within a narrower context if necessary
		// Adding a descendant combinator will generate what is needed
		if ( checkContext ) {
			soFar = " " + soFar;
		}

		while ( soFar ) {
			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				soFar = soFar.slice( match[0].length );

				// Cast descendant combinators to space
				matched = tokens.push({ part: match.pop().replace( rtrim, " " ), captures: match });
			}

			// Filters
			for ( type in filters ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match, context, xml )) ) ) {

					soFar = soFar.slice( match.shift().length );
					matched = tokens.push({ part: type, captures: match });
				}
			}

			if ( !matched ) {
				break;
			}
		}
	}

	if ( !matched ) {
		Sizzle.error( selector );
	}

	return groups;
}

function addCombinator( matcher, combinator, context ) {
	var dir = combinator.dir,
		doneName = done++;

	if ( !matcher ) {
		// If there is no matcher to check, check against the context
		matcher = function( elem ) {
			return elem === context;
		};
	}
	return combinator.first ?
		function( elem, context ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 ) {
					return matcher( elem, context ) && elem;
				}
			}
		} :
		function( elem, context ) {
			var cache,
				dirkey = doneName + "." + dirruns,
				cachedkey = dirkey + "." + cachedruns;
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 ) {
					if ( (cache = elem[ expando ]) === cachedkey ) {
						return elem.sizset;
					} else if ( typeof cache === "string" && cache.indexOf(dirkey) === 0 ) {
						if ( elem.sizset ) {
							return elem;
						}
					} else {
						elem[ expando ] = cachedkey;
						if ( matcher( elem, context ) ) {
							elem.sizset = true;
							return elem;
						}
						elem.sizset = false;
					}
				}
			}
		};
}

function addMatcher( higher, deeper ) {
	return higher ?
		function( elem, context ) {
			var result = deeper( elem, context );
			return result && higher( result === true ? elem : result, context );
		} :
		deeper;
}

// ["TAG", ">", "ID", " ", "CLASS"]
function matcherFromTokens( tokens, context, xml ) {
	var token, matcher,
		i = 0;

	for ( ; (token = tokens[i]); i++ ) {
		if ( Expr.relative[ token.part ] ) {
			matcher = addCombinator( matcher, Expr.relative[ token.part ], context );
		} else {
			token.captures.push( context, xml );
			matcher = addMatcher( matcher, Expr.filter[ token.part ].apply( null, token.captures ) );
		}
	}

	return matcher;
}

function matcherFromGroupMatchers( matchers ) {
	return function( elem, context ) {
		var matcher,
			j = 0;
		for ( ; (matcher = matchers[j]); j++ ) {
			if ( matcher(elem, context) ) {
				return true;
			}
		}
		return false;
	};
}

var compile = Sizzle.compile = function( selector, context, xml ) {
	var tokens, group, i,
		cached = compilerCache[ selector ];

	// Return a cached group function if already generated (context dependent)
	if ( cached && cached.context === context ) {
		return cached;
	}

	// Generate a function of recursive functions that can be used to check each element
	group = tokenize( selector, context, xml );
	for ( i = 0; (tokens = group[i]); i++ ) {
		group[i] = matcherFromTokens( tokens, context, xml );
	}

	// Cache the compiled function
	cached = compilerCache[ selector ] = matcherFromGroupMatchers( group );
	cached.context = context;
	cached.runs = cached.dirruns = 0;
	cachedSelectors.push( selector );
	// Ensure only the most recent are cached
	if ( cachedSelectors.length > Expr.cacheLength ) {
		delete compilerCache[ cachedSelectors.shift() ];
	}
	return cached;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	return Sizzle( expr, null, null, [ elem ] ).length > 0;
};

var select = function( selector, context, results, seed, xml ) {
	// Remove excessive whitespace
	selector = selector.replace( rtrim, "$1" );
	var elements, matcher, i, len, elem, token,
		type, findContext, notTokens,
		match = selector.match( rgroups ),
		tokens = selector.match( rtokens ),
		contextNodeType = context.nodeType;

	// POS handling
	if ( matchExpr["POS"].test(selector) ) {
		return handlePOS( selector, context, results, seed, match );
	}

	if ( seed ) {
		elements = slice.call( seed, 0 );

	// To maintain document order, only narrow the
	// set if there is one group
	} else if ( match && match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		if ( tokens.length > 1 && contextNodeType === 9 && !xml &&
				(match = matchExpr["ID"].exec( tokens[0] )) ) {

			context = Expr.find["ID"]( match[1], context, xml )[0];
			if ( !context ) {
				return results;
			}

			selector = selector.slice( tokens.shift().length );
		}

		findContext = ( (match = rsibling.exec( tokens[0] )) && !match.index && context.parentNode ) || context;

		// Get the last token, excluding :not
		notTokens = tokens.pop();
		token = notTokens.split(":not")[0];

		for ( i = 0, len = Expr.order.length; i < len; i++ ) {
			type = Expr.order[i];

			if ( (match = matchExpr[ type ].exec( token )) ) {
				elements = Expr.find[ type ]( (match[1] || "").replace( rbackslash, "" ), findContext, xml );

				if ( elements == null ) {
					continue;
				}

				if ( token === notTokens ) {
					selector = selector.slice( 0, selector.length - notTokens.length ) +
						token.replace( matchExpr[ type ], "" );

					if ( !selector ) {
						push.apply( results, slice.call(elements, 0) );
					}
				}
				break;
			}
		}
	}

	// Only loop over the given elements once
	// If selector is empty, we're already done
	if ( selector ) {
		matcher = compile( selector, context, xml );
		dirruns = matcher.dirruns++;

		if ( elements == null ) {
			elements = Expr.find["TAG"]( "*", (rsibling.test( selector ) && context.parentNode) || context );
		}
		for ( i = 0; (elem = elements[i]); i++ ) {
			cachedruns = matcher.runs++;
			if ( matcher(elem, context) ) {
				results.push( elem );
			}
		}
	}

	return results;
};

if ( dom.querySelectorAll ) {
	(function() {
		var disconnectedMatch,
			oldSelect = select,
			rescape = /'|\\/g,
			rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,
			rbuggyQSA = [],
			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			// A support test would require too much code (would include document ready)
			// just skip matchesSelector for :active
			rbuggyMatches = [":active"],
			matches = docElem.matchesSelector ||
				docElem.mozMatchesSelector ||
				docElem.webkitMatchesSelector ||
				docElem.oMatchesSelector ||
				docElem.msMatchesSelector;

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			div.innerHTML = "<select><option selected></option></select>";

			// IE8 - Some boolean attributes are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here (do not put tests after this one)
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {

			// Opera 10-12/IE9 - ^= $= *= and empty values
			// Should not select anything
			div.innerHTML = "<p test=''></p>";
			if ( div.querySelectorAll("[test^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here (do not put tests after this one)
			div.innerHTML = "<input type='hidden'>";
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push(":enabled", ":disabled");
			}
		});

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );

		select = function( selector, context, results, seed, xml ) {
			// Only use querySelectorAll when not filtering,
			// when this is not xml,
			// and when no QSA bugs apply
			if ( !seed && !xml && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
				if ( context.nodeType === 9 ) {
					try {
						push.apply( results, slice.call(context.querySelectorAll( selector ), 0) );
						return results;
					} catch(qsaError) {}
				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var old = context.getAttribute("id"),
						nid = old || expando,
						newContext = rsibling.test( selector ) && context.parentNode || context;

					if ( old ) {
						nid = nid.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}

					try {
						push.apply( results, slice.call( newContext.querySelectorAll(
							selector.replace( rgroups, "[id='" + nid + "'] $&" )
						), 0 ) );
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}

			return oldSelect( selector, context, results, seed, xml );
		};

		if ( matches ) {
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				try {
					matches.call( div, "[test!='']:sizzle" );
					rbuggyMatches.push( Expr.match.PSEUDO );
				} catch ( e ) {}
			});

			// rbuggyMatches always contains :active, so no need for a length check
			rbuggyMatches = /* rbuggyMatches.length && */ new RegExp( rbuggyMatches.join("|") );

			Sizzle.matchesSelector = function( elem, expr ) {
				// Make sure that attribute selectors are quoted
				expr = expr.replace( rattributeQuotes, "='$1']" );

				// rbuggyMatches always contains :active, so no need for an existence check
				if ( !isXML( elem ) && !rbuggyMatches.test( expr ) && (!rbuggyQSA || !rbuggyQSA.test( expr )) ) {
					try {
						var ret = matches.call( elem, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9
								elem.document && elem.dom.nodeType !== 11 ) {
							return ret;
						}
					} catch(e) {}
				}

				return Sizzle( expr, null, null, [ elem ] ).length > 0;
			};
		}
	})();
}

return Sizzle;

};


// File contents end
    return exports;
}


// Imported from: src/toolkit.js
libraries['./toolkit'] = function () {
    var exports = {};
// File contents begin
// This is the default toolkit. This is the mechanism for changing bits of
// ziprip that you don't like - knock out or change the functionality of parts
// of this.

// Accepts a found address, and returns a copy that's simplified and/or cleaned
// for geocoding. The default is entirely English-language specific...
exports.cleanAddress = zrRequire('./cleanAddress_en')['cleanAddress'];

// Accepts a DOM node and tries to get its text content in a nice way
exports.nodeToText = zrRequire('./nodeToText')['nodeToText'];

// Accepts a DOM representing a whole page, and tries converting it to text
exports.domToText = zrRequire('./domToText')['domToText'];

// Given plain-text, tries to find addresses in it. Quite a few of the routines
// rely on this - it's probably the main clever part of the whole library - the
// generic extractor is a thin wrapper around it
exports.addressFromString = zrRequire('./addressFromString')['addressFromString'];

// JSON wrangler. Expected to support as least 'parse' and 'stringify'
exports.json = zrRequire('./json2')['json'];

// Sizzle and its loader
var sizzle = zrRequire('./sizzle');
exports.sz = sizzle['sz'];
exports.loadSizzle = sizzle['loadSizzle'];

// jsuri
exports.uri = zrRequire('./jsuri')['uri'];

// Create a new address container for passing back to the caller
var address = zrRequire('./address');
exports.address = address['address'];
exports.addressFromFields = address['addressFromFields'];
// File contents end
    return exports;
}


// Imported from: src/ziprip.js
libraries['./ziprip'] = function () {
    var exports = {};
// File contents begin

// Usual way in to the library

//
// METHODS
// 	extract() accepts a DOM object, and a string URL, and returns address
//  address objects.
//

// Load the toolkit
exports._zipripToolkit = zrRequire('./toolkit');

// Extractors to load
var extractorModules = ['Google','HVCard','FromText'];
var extractors = [];
for (var i = 0; i < extractorModules.length; i++) {
    var extractor = zrRequire('./extractor' + extractorModules[i])['extractor'];
    extractors.push( extractor );
}

// Load the lower-level extraction interface
var extractUsing = zrRequire('./extractUsing')['extractUsing'];

exports.extract = function ( dom, url ) {
    return extractUsing( dom, url, exports._zipripToolkit, {}, extractors);
}

exports.version = "0.0.1";


// File contents end
    return exports;
}



if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = zrRequire('./ziprip');
    }
    exports.ziprip = zrRequire('./ziprip');
} else {
    this['ziprip'] = zrRequire('./ziprip');
}

}).call(this);